
#include <iostream>
#include<vector>
using namespace std;
vector<int> max_heapify(vector<int>&v,int k); //这个函数输入向量v和下标k，向量v满足LEFT（k）,RIGHT(k)均是最大堆，A[k]可能小于孩子，此算法讲k处对应子树调整为最大堆；

int parent(int i){return (i-1)/2;}
int left(int i){return 2*i+1;}
int right(int i){return 2*i+2;}


int main(int argc, const char * argv[]) {
    vector<int> vec;
    int n,newnumber,i;
    cin>>n;
    for(i=0;i<n;i++){
        cin>>newnumber;
        vec.push_back(newnumber);
    }
    vec = max_heapify(vec, 0);
    for(i =0;i<n;i++){cout<<vec[i]<<endl;}
    return 0;
}

vector<int> max_heapify(vector<int>&v,int k)
{
    int l,r,n,maxnumber,temp;
    l = left(k);r = right(k);n=v.size();
    if((l>n && r>n)||(l<=n && r <=n && v[k]>=v[l] && v[k]>=v[r]) || (l<=n && r>n && v[k] >= v[l])){return v;}
    else
    {
        if(l <= n && v[l]>v[k]){maxnumber = l;}
        if(r <= n && v[r] > v[k]){maxnumber = r;}
        temp = v[k];v[k] = v[maxnumber];v[maxnumber] = temp;
        max_heapify(v,maxnumber);return v;
    }
}
